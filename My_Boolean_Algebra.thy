header {* Boolean Algebras *}

theory My_Boolean_Algebra
  imports Main Mult
begin

(*declare [[ smt_solver = remote_z3]]
declare [[ smt_timeout = 60 ]]
declare [[ z3_options = "-memory:500" ]]
*)

section {* Boolean Algebras *}

text {* This file contains our own Boolean algebra laws. It is based
on Huntington's axioms (the first three axioms below), in which the
order, one, zero and meet can be defined. The laws proved follow more
or less Roger Maddux's book on relation algebras and J\'onsson and
Tarski's articles on Boolean algebras with operators. The theory is
later used in the context of relation algebras.

Isabelle has, of course, its own Boolean algebras, but we have
formalised this one for two reasons. First, Huntington's axioms are
rather minimalist, hence when establishing subclasses or sublocales
there are only a few axioms to check. Second, again due to this
minimality, it is initially very difficult to derive the usual laws
from these axioms, which makes this file a good testbed for proof
automation.
*}

class boolean_algebra = plus + ord + uminus + one + zero + mult +
  assumes join_assoc: "(x+y)+z = x+(y+z)"
  and join_comm: "x+y = y+x"
  and compl: "x = -((-x)+(-y))+(-((-x)+y))"
  and leq_def: "x \<le> y \<longleftrightarrow> x+y = y"
  and strict_leq_def: "x < y \<longleftrightarrow> x \<le> y \<and> \<not> (y \<le> x)"
  and one_def: "x+(-x) = 1" 
  and zero_def: "(- 1) = 0" 
  and meet_def: "x\<cdot>y = -((-x)+(-y))"

begin

subclass order
proof
  fix x y z :: 'a
  show "x \<le> x"
    by (metis compl join_assoc leq_def meet_def one_def)
   show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y"
     by (metis join_comm leq_def)
   show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z"
     by (metis join_assoc leq_def)
  show  "x < y \<longleftrightarrow> x \<le> y \<and> \<not> (y \<le> x)"
    by (metis strict_leq_def)
qed

text {* We first show that all operations are isotone *}

lemma join_iso: "x \<le> y \<longrightarrow> x+z \<le> y+z"
  by (metis join_assoc join_comm leq_def order_refl)

lemma comp_anti: "x \<le> y \<longleftrightarrow> -y \<le> -x"
  by (metis compl join_comm join_iso leq_def one_def)

lemma meet_iso: "x \<le> y \<longrightarrow> x\<cdot>z \<le> y\<cdot>z"
  by (metis join_iso comp_anti meet_def)

text {* We now show that $0$ and $1$ are the least and greatest
elements of the order *}

lemma zero_min: "0 \<le> x"
  by (metis compl join_comm leq_def one_def order_refl zero_def)

lemma one_max: "x \<le> 1"
  by (metis comp_anti zero_def zero_min)

text {* We now give the definition of the order with respect to meet. The proof has been generated by Isar Proof. *}

lemma leq_meet: "x \<le> y \<longleftrightarrow> x\<cdot>y = x"
proof -
  have F1: "\<forall>x\<^isub>1\<Colon>'a. x\<^isub>1 \<le> x\<^isub>1" by (metis compl leq_def meet_def meet_iso one_max)
  { assume "\<not> x \<le> y"
    hence "(x \<le> y) = (x \<cdot> y = x)" by (metis compl leq_def meet_def meet_iso one_max) }
  thus "(x \<le> y) = (x \<cdot> y = x)" by (metis F1 compl leq_def meet_def meet_iso one_max)
qed

text {* We now exstablish the (least) upper bound and (greatest) lower bound properties of join and meet *}

lemma join_ub: "x \<le> x+y"
  by (metis join_comm join_iso leq_def zero_min)

lemma join_lub: "x+y \<le> z \<longleftrightarrow> x \<le> z \<and> y \<le> z"
  by (metis join_comm join_iso join_ub leq_def)

lemma meet_lb: "x\<cdot>y \<le> x"
  by (metis compl join_comm join_ub meet_def)

lemma meet_glb: "z \<le> x\<cdot>y \<longleftrightarrow> z\<le>x \<and> z\<le>y"
  by (metis join_comm leq_meet meet_def meet_iso meet_lb order_trans)

text {* We now show the equational join and meet semilattice properties *}

lemma join_idem: "x+x = x"
  by (metis leq_def order_refl)

lemma meet_assoc: "(x\<cdot>y)\<cdot>z = x\<cdot>(y\<cdot>z)"
  by (metis eq_iff meet_glb meet_iso)

lemma meet_comm: "x\<cdot>y = y\<cdot>x"
proof -
  have F1: "\<forall>(x\<^isub>2\<Colon>'a) x\<^isub>1\<Colon>'a. x\<^isub>1 \<cdot> x\<^isub>2 \<cdot> (x\<^isub>2 \<cdot> x\<^isub>1) = x\<^isub>2 \<cdot> x\<^isub>1" by (metis eq_iff meet_glb)
  have "\<forall>(x\<^isub>2\<Colon>'a) x\<^isub>1\<Colon>'a. x\<^isub>1 \<cdot> x\<^isub>2 \<cdot> x\<^isub>1 = x\<^isub>1 \<cdot> x\<^isub>2" by (metis eq_iff meet_glb)
  hence "\<forall>(x\<^isub>2\<Colon>'a) x\<^isub>1\<Colon>'a. x\<^isub>1 \<cdot> x\<^isub>2 = x\<^isub>2 \<cdot> x\<^isub>1" by (metis F1)
  thus "x \<cdot> y = y \<cdot> x" by metis
qed

lemma meet_idem: "x\<cdot>x = x"
  by (metis leq_meet order_refl)

text {* Next we show the absorption laws of lattice theory *}

lemma absorption1: "(x+y)\<cdot>x = x"
  by (metis join_comm join_ub leq_meet meet_def)

lemma absorption2: "x+x\<cdot>y=x"
  by (metis join_comm leq_def meet_lb)

text {* Next we prove some simple laws about $0$ and $1$ *}

lemma one_plus: "x+1 =1"
  by (metis leq_def one_max)

lemma one_times: "x\<cdot>1 = x"
  by (metis join_comm join_idem leq_def meet_def meet_idem zero_def zero_min)

lemma zero_plus: "x+0 = x"
  by (metis join_comm leq_def zero_min)

lemma zero_times: "x\<cdot>0 = 0"
  by (metis join_comm leq_meet meet_def zero_min)

text {* Next we prove some laws about complementation *}

lemma double_compl: "-(-x) = x"
  by (metis join_idem meet_def meet_idem)

lemma de_morgan_1: "-(x+y) = (-x)\<cdot>(-y)"
  by (metis double_compl meet_def)

lemma de_morgan_2: "-(x\<cdot>y) = (-x)+(-y)"
  by (metis double_compl meet_def)

lemma de_morgan_3: "x+y = -((-x)\<cdot>(-y))"
  by (metis double_compl meet_def)

lemma zero_meet: "x\<cdot>(-x) = 0"
  by (metis meet_def one_def zero_def)

lemma zero_one: "(- 0) =1"
  by (metis double_compl zero_def)

text {* Next we show the distributivity laws *}

text {* We first prove some auxiliary lemmas *}

lemma subdist_1_var:  "x\<cdot>y \<le> x\<cdot>(y+z)"
  by (metis join_ub meet_glb order_refl order_trans)

lemma subdist_1:  "x\<cdot>y+x\<cdot>z \<le> x\<cdot>(y+z)"
  by (metis join_comm join_lub subdist_1_var)

lemma subdist_2_var: "x+(y\<cdot>z) \<le>x+y"
  by (metis absorption2 join_lub join_ub)

lemma subdist_2: "x+(y\<cdot>z) \<le>(x+y)\<cdot>(x+z)"
  by (metis meet_comm meet_glb subdist_2_var)

lemma ba_3: "x = x\<cdot>y+x\<cdot>(-y)"
  by (metis compl join_comm meet_def)

lemma ba_5: "(x+y)\<cdot>(-x) = y\<cdot>(-x)"
  by (smt compl join_assoc join_comm join_idem leq_def meet_def subdist_1_var meet_comm meet_idem)

lemma dist_1: "x\<cdot>(y+z) = x\<cdot>y+x\<cdot>z"
  by (metis ba_3 meet_assoc ba_5 absorption1 subdist_2_var subdist_1 eq_iff)

lemma dist_2: "x+y\<cdot>z = (x+y)\<cdot>(x+z)"
  by (metis double_compl dist_1 de_morgan_1)

lemma dist_alt: "x+z=y+z \<longrightarrow> x\<cdot>z = y\<cdot>z \<longrightarrow> x=y"
  by (metis absorption2 join_comm dist_2 meet_comm)

text {* We now prove some additional lemmas from Maddux's book *}

lemma compl_1: "-x = -(x+y)+(-(x+(-y)))"
  by (metis join_comm compl double_compl)

lemma ba_1: "x+y+(-y) = z+(-z)"
  by (metis ba_5 de_morgan_3 double_compl meet_comm zero_meet)

lemma ba_2: "x+x = x+(-(y+(-y)))"
  by (metis join_assoc join_comm ba_1 compl_1 double_compl)

lemma ba_4: "x = (x+(-y))\<cdot>(x+y)"
  by (metis compl meet_def meet_idem)

text {* We now prove the Galois connections for complementation *}

lemma galois_1: "x\<cdot>(-y) \<le> z \<longleftrightarrow> x \<le> y+z"
proof
  assume "x \<le> y+z"
  thus  "x\<cdot>(-y) \<le> z"
    by (metis meet_iso ba_5 meet_comm meet_glb)
next
  assume hyp: "x\<cdot>(-y) \<le> z"
  thus  "x \<le> y+z" 
    by (smt join_iso join_comm join_lub dist_2 one_def one_times)
qed

lemma galois_2: "x \<le> y+(-z) \<longleftrightarrow> x\<cdot>z \<le> y"
  by (metis join_comm double_compl galois_1)

lemma galois_aux: "x\<cdot>y = 0 \<longleftrightarrow> x \<le> -y"
  by (metis galois_2 leq_def meet_glb zero_plus zero_times)

section {* Conjugation and Boolean Algebras with Operators *}

text {* We follow J\'onsson and Tarski to define pairs of conjugate
functions on Boolean algebras. This gives rise to a Galois connection
and the notion of Boolean algebras with operators. 

However, we do not explicitly define families of functions over
Boolean algebras.

This section should certainly be expanded. We can apply its content in
various ways, for example, in relation algebra to derive the modular
laws by instantiation, and for antidomain semirings where modal
operators satisfy conjugations and Galois connections.
*}

text{* We define conjugation as a predicate which holds if a pair of
functions is conjugate *}

abbreviation conjugation_p :: "('a \<Rightarrow> 'a) \<Rightarrow> ('a \<Rightarrow> 'a) \<Rightarrow> bool"
 where "conjugation_p f g == (\<forall> x y . ((f x)\<cdot>y = 0 \<longleftrightarrow> x\<cdot>(g y) = 0))"

text{* We now prove the standard lemmas *}

lemma conj_p_sym : "conjugation_p f g \<longleftrightarrow> conjugation_p g f"
  by (metis meet_comm)

text {* We translated the manual proof because it is so elegant *}

lemma f_pre_additive:
  assumes "conjugation_p f g"
  shows "f (x+y) \<le> z \<longleftrightarrow> (f x)+(f y) \<le> z"
proof -
  have "f (x+y) \<le> z \<longleftrightarrow> (f (x+y))\<cdot>(-z) = 0"
    by (metis double_compl galois_aux)
  hence "f (x+y) \<le> z \<longleftrightarrow> (x\<cdot>(g (-z))+y\<cdot>(g (-z)) = 0)"
    by (metis assms dist_1 meet_comm)
  hence "f(x+y) \<le> z \<longleftrightarrow> (x\<cdot>g(-z) = 0 \<and> y\<cdot>g(-z) = 0)"
    by (metis join_ub leq_def zero_min zero_plus)
  hence "f(x+y) \<le> z \<longleftrightarrow> ((f x)\<cdot>(-z) = 0 \<and> (f y)\<cdot>(-z) = 0)"
    by (metis assms)
  hence "f (x+y) \<le> z \<longleftrightarrow> ((f x)+(f y))\<cdot>(-z) = 0"
    by (metis join_lub galois_aux)
  thus ?thesis by (metis double_compl galois_aux)
qed

lemma f_additive: 
    assumes "conjugation_p f g"
    shows "f (x+y) = (f x)+(f y)"
  by (metis assms eq_iff f_pre_additive)

lemma g_pre_additive: 
  assumes "conjugation_p f g"
  shows "g (x+y) \<le> z \<longleftrightarrow> (g x)+(g y) \<le> z"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis f_pre_additive)
qed

lemma g_additive: 
  assumes "conjugation_p f g"
  shows "g(x+y) = g(x)+g(y)"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis f_additive)
qed

text {* This proof would be simpler if Isabelle wouldn't expand the assumption\<dots> *}

lemma f_iso: 
  assumes "conjugation_p f g"
  shows "x \<le> y  \<longrightarrow> f(x) \<le> f(y)"
  by (metis assms f_additive leq_def)

lemma g_iso: 
  assumes "conjugation_p f g"
  shows "x \<le> y  \<longrightarrow> g(x) \<le> g(y)"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis f_iso)
qed

lemma cancellation_1:
  assumes "conjugation_p f g"
  shows "f(-g(x)) \<le> -x"
  by (metis meet_comm zero_meet assms galois_aux)

lemma cancellation_2: 
  assumes "conjugation_p f g"
  shows "g(-f(x)) \<le> -x"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis cancellation_1)
qed

lemma f_subdist: 
  assumes "conjugation_p f g"
  shows "f(x\<cdot>y) \<le> f(x)"
  by (metis assms f_iso meet_lb)

lemma g_subdist: 
  assumes "conjugation_p f g"
  shows "g(x\<cdot>y) \<le> g(x)"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis f_subdist)
qed

lemma f_strict: 
  assumes "conjugation_p f g"
  shows "f(0) = 0"
  by (metis assms cancellation_1 f_iso leq_def zero_def zero_min zero_plus)

lemma g_strict: 
  assumes "conjugation_p f g"
  shows "g(0) = 0"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis f_strict)
qed

lemma conj_galois_1: 
  assumes "conjugation_p f g"
  shows "f(x) \<le> y \<longleftrightarrow> x \<le> -g(-y)"
  by (metis assms double_compl galois_aux)

lemma conj_galois_2: 
  assumes "conjugation_p f g"
  shows "g(x) \<le> y \<longleftrightarrow> x \<le> -f(-y)"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis conj_galois_1)
qed

lemma modular_1_aux: 
  assumes "conjugation_p f g"
  shows "f(x\<cdot>(-g(y)))\<cdot>y = 0"
  by (metis assms meet_assoc meet_comm zero_meet zero_times)

lemma modular_2_aux: 
  assumes "conjugation_p f g"
  shows "g(x\<cdot>(-f(y)))\<cdot>y = 0"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis modular_1_aux)
qed

lemma modular_1: 
  assumes "conjugation_p f g"
  shows "f(x)\<cdot>y = f(x\<cdot>g(y))\<cdot>y"
proof -
  have "f(x)\<cdot>y = f(x\<cdot>g(y)+x\<cdot>(-g(y)))\<cdot>y"
    by (metis ba_3 meet_comm)
  hence  "f(x)\<cdot>y = (f(x\<cdot>g(y))+f(x\<cdot>(-g(y))))\<cdot>y"
    by (metis assms f_additive) 
  hence  "f(x)\<cdot>y = f(x\<cdot>g(y))\<cdot>y+f(x\<cdot>(-g(y)))\<cdot>y"
    by (metis meet_comm dist_1) 
  thus ?thesis  by (metis assms modular_1_aux zero_plus)
qed

lemma modular_2:  
  assumes "conjugation_p f g"
  shows "g(x)\<cdot>y = g(x\<cdot>f(y))\<cdot>y"
proof -
  have "conjugation_p g f"
    by (metis assms conj_p_sym)
  thus  ?thesis by (metis modular_1)
qed

end

end
